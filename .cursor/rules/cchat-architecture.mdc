---
description: 
globs: 
alwaysApply: false
---
---
title: CChat Application Architecture
description: Guidelines for the architecture, conventions, and patterns for the CChat server and client application.
glob: "**/*.{go,tsx,ts,jsx,js,css,html,sql}"
alwaysApply: true
---
# CChat Application Architecture

## Introduction

This rule defines the architecture, structure, and coding conventions for the CChat application, a real-time chat platform with a Go backend and React frontend. Understanding these patterns is essential for maintaining consistency and ensuring the application's scalability and maintainability.

## System Overview

CChat consists of two main components:
1. A Go backend server with PostgreSQL database 
2. A React/TypeScript frontend web application

### Key Features
- User registration and authentication (username/password with email verification)
- Multiple chat spaces creation and management
- Direct messaging between users
- Group messaging in spaces
- Real-time communication using WebSockets

## Backend Architecture (Go)

### Directory Structure

```
server/
├── cmd/               # Main applications and entry points
│   └── server/        # Main server application
├── internal/          # Private application code
│   ├── api/           # API handlers
│   ├── auth/          # Authentication logic
│   ├── db/            # Database connection and queries
│   ├── models/        # Data models
│   ├── middleware/    # HTTP middleware
│   ├── spaces/        # Chat spaces logic
│   ├── users/         # User management
│   └── messages/      # Messaging functionality
```

### Conventions

#### Package Structure
- Each feature area should have its own package (users, spaces, messages)
- Models should be defined in the `models` package
- Database access should happen through the `db` package
- API handlers should be organized in the `api` package

#### Error Handling
- Use wrapped errors with descriptive context
- Return appropriate HTTP status codes with error messages

```go
// Good pattern for error handling
if err != nil {
    return fmt.Errorf("failed to create user: %w", err)
}
```

#### Database Access
- Use transactions for operations that affect multiple tables
- Prefer parameterized queries over string concatenation
- Use UUID for primary keys

```go
// Good pattern for database queries
const createUserQuery = `
    INSERT INTO users (username, email, password_hash)
    VALUES ($1, $2, $3)
    RETURNING id, created_at
`
```

#### Authentication
- Use JWT for authentication
- Include user ID and role in JWT claims
- Require email verification for new accounts

## Frontend Architecture (React/TypeScript)

### Directory Structure

```
client/
├── public/            # Static assets
└── src/               # Source code
    ├── components/    # React components
    ├── pages/         # Page components
    ├── hooks/         # Custom React hooks
    ├── services/      # API services
    └── styles/        # CSS and styling
```

### Conventions

#### Component Structure
- Use functional components with hooks
- Define prop types with TypeScript interfaces
- Group related components in subdirectories

```typescript
// Component template
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
}

const Button: React.FC<ButtonProps> = ({ label, onClick, variant = 'primary' }) => {
  return (
    <button 
      className={`btn btn-${variant}`} 
      onClick={onClick}
    >
      {label}
    </button>
  );
};
```

#### State Management
- Use React Context for global state
- Use React Query for server state
- Use local state (useState) for component-specific state

#### Styling
- Use CSS modules or styled components
- Follow a consistent naming convention
- Use responsive design principles

## API Conventions

### Endpoints

- RESTful API structure
- JSON request/response format
- Consistent error response format

```
GET     /api/users                # List users
GET     /api/users/:id            # Get user
POST    /api/users                # Create user
PUT     /api/users/:id            # Update user
DELETE  /api/users/:id            # Delete user

GET     /api/spaces               # List spaces
POST    /api/spaces               # Create space
GET     /api/spaces/:id           # Get space
PUT     /api/spaces/:id           # Update space
DELETE  /api/spaces/:id           # Delete space
POST    /api/spaces/:id/members   # Add member to space

GET     /api/messages?space=:id   # Get messages in space
POST    /api/messages             # Create message
```

### WebSocket Communication

- Use WebSocket for real-time messaging
- Implement reconnection logic
- Message format should be consistent

## Database Schema

### Key Tables

- `users`: User accounts and authentication
- `spaces`: Chat rooms or channels
- `space_members`: Junction table for users in spaces
- `messages`: Chat messages (both direct and in spaces)
- `session_tokens`: Authentication sessions
- `password_reset_tokens`: Password reset functionality

### Relationships

- Users can belong to multiple spaces (many-to-many via space_members)
- Messages can be in a space or direct between users
- Each space has a creator (user)

## Development Workflow

1. Create or update database models when needed
2. Implement backend functionality (Go)
3. Create API endpoints
4. Implement frontend components and pages
5. Connect frontend to backend via API calls
6. Test end-to-end functionality

## Common Pitfalls

- Not handling WebSocket reconnection properly
- Forgetting to validate user permissions for actions
- Exposing sensitive information in API responses
- Not handling database connections efficiently
- Missing input validation on both client and server